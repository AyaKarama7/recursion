Recursion=subproblem with smaller costraints from problem with bigger constraints
تنفيز المهام بالتزامن او التوازي
datatybe rec_name(parametres)
{
  base case;
  return case;
}
example:factorial
int factorial(int n)
{
   if(n==1)return 1;//base case
   return factorial(n-1)*n;//return case
}
//n=6=f(5)*6=fac(4)*5*6...بعدين الفانكشن بتتنفز من الاخر 
*we have 2 cases:
-we call the function inside it self يعني بنادي الفانكشن جوا نفسها و بتتنفز بالترتيب
void print(int n)//6 3 10 5
{
    if(n==1)return;
    cout<<n<<' ';//6 3 10 
    if(n%2==0)print(n/2);//3 
    else print(n*3+1);
}
-بننادي كل الفانكشنز من الاول للاخر بعدين تتنفز من الاخر وكل فانكشن ترجع القيمه للي قبلها
int factorial(int n)
{
   if(n==1)return 1;//base case
   return factorial(n-1)*n;//return case
}
-order:
n=5
base-->build-->recall--->5 4 3 2 1 || build-->base--->recall
base-->recall->build---->1 2 3 4 5
*feponacci:
int fepo(int n)//O(2^n)//
{
    if(n==0)return 0;//base
    if(n==1)return 1;//base 
    return fepo(n-1)+fepo(n-2);//recall
    //builld in main
}
*you can represent recursive function as a tree of nodes and get the answer ordered from first recursive function
*f(n) = f(n+1) + f(n-1)    ⇒  equivalent to ⇒  f(n+1) = f(n) - f(n-1)
*******************************************************************************************************************
1-print forward:
void print(int n)
{
    if(n==0)return;
    print(n-1);
    cout<<n<<'\n';
}
-print backward:
void print(int n)
{
    if(n==0)return;
    if(n==1)cout<<n;
    else cout<<n<<' ';
    return print(n-1);
}
****************************************************************************************************************
2-print max:
int Max(int n,vector<int>&v)
{
    if(n==1)return v[0];
    int subp=Max(n-1,v);
    return max(subp,v[n-1]);
}
